{
  "cells": [
    {
      "cell_type": "code",
      "source": [
        "!pip uninstall lingua -y\n",
        "!pip uninstall lingua-language-detector -y\n",
        "!pip install lingua-language-detector\n",
        "!pip show lingua-language-detector\n",
        "!pip install deep_translator"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "sg8QsJrZ5hz3",
        "outputId": "f75a9f1e-45b8-45b8-aff2-c7aa74b23fc5"
      },
      "execution_count": 24,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[33mWARNING: Skipping lingua as it is not installed.\u001b[0m\u001b[33m\n",
            "\u001b[0mFound existing installation: lingua-language-detector 2.0.2\n",
            "Uninstalling lingua-language-detector-2.0.2:\n",
            "  Successfully uninstalled lingua-language-detector-2.0.2\n",
            "Collecting lingua-language-detector\n",
            "  Using cached lingua_language_detector-2.0.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (349 kB)\n",
            "Using cached lingua_language_detector-2.0.2-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (74.7 MB)\n",
            "Installing collected packages: lingua-language-detector\n",
            "Successfully installed lingua-language-detector-2.0.2\n",
            "Name: lingua-language-detector\n",
            "Version: 2.0.2\n",
            "Summary: An accurate natural language detection library, suitable for short text and mixed-language text\n",
            "Home-page: https://github.com/pemistahl/lingua-rs\n",
            "Author: Peter M. Stahl <pemistahl@gmail.com>\n",
            "Author-email: \"Peter M. Stahl\" <pemistahl@gmail.com>\n",
            "License: Apache-2.0\n",
            "Location: /usr/local/lib/python3.10/dist-packages\n",
            "Requires: \n",
            "Required-by: \n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 60,
      "metadata": {
        "id": "SIpYkIA_5CZq"
      },
      "outputs": [],
      "source": [
        "import requests\n",
        "import re\n",
        "from lingua import LanguageDetectorBuilder, Language\n",
        "from deep_translator import GoogleTranslator\n",
        "\n",
        "# Azure OpenAI 및 Azure Search 설정\n",
        "AZURE_OPENAI_ENDPOINT = 'https://openai-team3.openai.azure.com/'\n",
        "AZURE_OPENAI_API_KEY = '7u1gKFj9UhcAVQD1lLfCIrlXGVWm894NEljVILS0jG7z95cCwSkHJQQJ99ALACHYHv6XJ3w3AAABACOGKTgQ'\n",
        "DEPLOYMENT_NAME = 'gpt-4o'\n",
        "SEARCH_ENDPOINT = \"https://ai-search-team3.search.windows.net\"\n",
        "SEARCH_API_KEY = \"SVteEFiHV62vyfZ56a6xsfba10kfSLoGseuenSigufAzSeCa4IB1\"\n",
        "SEARCH_INDEX_NAME = \"keyword-index\"\n",
        "SEMANTIC_CONFIGURATION = \"keyword-semantic\"\n",
        "\n",
        "# 언어 감지기 초기화\n",
        "detector = LanguageDetectorBuilder.from_all_languages().build()\n",
        "\n",
        "def detect_language(text):\n",
        "    \"\"\"텍스트의 언어를 감지\"\"\"\n",
        "    detected_language = detector.detect_language_of(text)\n",
        "    if detected_language is not None:\n",
        "        return detected_language.name.lower()  # 언어 이름을 소문자로 반환\n",
        "    else:\n",
        "        return \"unknown\"\n",
        "\n",
        "def translate_to_korean(text):\n",
        "    \"\"\"사용자 입력을 한국어로 번역\"\"\"\n",
        "    try:\n",
        "        return GoogleTranslator(source='auto', target='ko').translate(text)\n",
        "    except Exception as e:\n",
        "        print(f\"Error in translation: {e}\")\n",
        "        return text  # 번역 실패 시 원본 텍스트 반환\n",
        "\n",
        "def clean_response(text):\n",
        "    \"\"\"불필요한 기호 및 문구를 정리하는 함수\"\"\"\n",
        "    cleaned_text = re.sub(r'\\[doc\\d+\\]', '', text)\n",
        "    cleaned_text = re.sub(r'[\\[\\]]', '', cleaned_text)\n",
        "    return cleaned_text.strip()\n",
        "\n",
        "def validate_citations(citations):\n",
        "    \"\"\"\n",
        "    Citations 내용이 비어있거나 너무 짧은 경우 False 반환.\n",
        "    \"\"\"\n",
        "    print(f\"\\nValidating citations... Total citations: {len(citations)}\")\n",
        "    if not citations:\n",
        "        print(\"\\nNo citations found.\")\n",
        "        return False\n",
        "    for i, citation in enumerate(citations):\n",
        "        content = citation.get('content', '')\n",
        "        print(f\"\\nCitation {i + 1}: {content[:50]}...\")  # 첫 50자만 출력\n",
        "        if len(content.strip()) < 1:  # 너무 짧은 내용은 무효 처리\n",
        "            print(\"Invalid citation detected (too short).\")\n",
        "            return False\n",
        "    return True\n",
        "\n",
        "def summarize_with_gpt(citations, user_input, target_language):\n",
        "    \"\"\"Citation 데이터를 요약하여 질문에 답변 생성\"\"\"\n",
        "    print(\"\\nSummarizing citations using GPT...\")\n",
        "    combined_text = \" \".join([citation.get('content', '').strip() for citation in citations])\n",
        "\n",
        "    summarization_prompt = f\"\"\"\n",
        "    Question: {user_input}\n",
        "    Summarize the following information in {target_language} to answer the question:\n",
        "    {combined_text}\n",
        "    \"\"\"\n",
        "\n",
        "    payload = {\"messages\": [{\"role\": \"user\", \"content\": summarization_prompt}], \"temperature\": 0.7, \"max_tokens\": 1000}\n",
        "    headers = {\"Content-Type\": \"application/json\", \"api-key\": AZURE_OPENAI_API_KEY}\n",
        "\n",
        "    response = requests.post(\n",
        "        f\"{AZURE_OPENAI_ENDPOINT}openai/deployments/{DEPLOYMENT_NAME}/chat/completions?api-version=2024-02-15-preview\",\n",
        "        headers=headers, json=payload\n",
        "    )\n",
        "\n",
        "    if response.status_code == 200:\n",
        "        return clean_response(response.json()['choices'][0]['message']['content'].strip())\n",
        "    else:\n",
        "        print(f\"Error during summarization: {response.status_code}\")\n",
        "        return \"An error occurred while summarizing the citations.\"\n",
        "\n",
        "def fallback_to_gpt(question, language):\n",
        "    \"\"\"Search 실패 시 GPT 자체 지식으로 답변 생성\"\"\"\n",
        "    print(\"Executing fallback: Generating response using GPT knowledge.\")\n",
        "    fallback_prompt = f\"\"\"\n",
        "    Question: {question}\n",
        "    Answer (in {language}): If the question is related to Korean law, provide a detailed and accurate response based on general legal knowledge specific to Korean law.\n",
        "\n",
        "    At the end of your legal response, include this message translated into {language}:\n",
        "    'Please refer to trusted legal sources to verify the most up-to-date information.'\n",
        "\n",
        "    If the question is not related to law (e.g., greetings, insults, unrelated content), respond with:\n",
        "    'I can only answer questions related to Korean law. Please ask questions about Korean legal matters.' in {language}\n",
        "    \"\"\"\n",
        "    payload = {\"messages\": [{\"role\": \"user\", \"content\": fallback_prompt}], \"temperature\": 0.7, \"max_tokens\": 1000}\n",
        "\n",
        "    headers = {\"Content-Type\": \"application/json\", \"api-key\": AZURE_OPENAI_API_KEY}\n",
        "    response = requests.post(\n",
        "        f\"{AZURE_OPENAI_ENDPOINT}openai/deployments/{DEPLOYMENT_NAME}/chat/completions?api-version=2024-02-15-preview\",\n",
        "        headers=headers,\n",
        "        json=payload\n",
        "    )\n",
        "    if response.status_code == 200:\n",
        "        return clean_response(response.json()['choices'][0]['message']['content'].strip())\n",
        "    else:\n",
        "        return \"An error occurred while generating the fallback response.\"\n",
        "\n",
        "def ask_legal_question(user_input):\n",
        "    \"\"\"질문에 대한 응답 반환\"\"\"\n",
        "    print(f\"\\nProcessing question: {user_input}\")\n",
        "\n",
        "    # 언어 감지 및 번역\n",
        "    detected_language = detect_language(user_input)\n",
        "    print(f\"\\nDetected language: {detected_language}\")\n",
        "    translated_question = translate_to_korean(user_input)\n",
        "    print(f\"\\nTranslated question for search: {translated_question}\")\n",
        "\n",
        "    headers = {\"Content-Type\": \"application/json\", \"api-key\": AZURE_OPENAI_API_KEY}\n",
        "    prompt = f\"Question: {translated_question}\\nAnswer: Provide an answer using retrieved documents in Korean.\"\n",
        "\n",
        "    payload = {\n",
        "        \"messages\": [\n",
        "            {\"role\": \"system\", \"content\": \"You are a multilingual assistant specializing in Korean law. Answer all questions about Korean law in the language of the question.\"},\n",
        "            {\"role\": \"user\", \"content\": prompt}\n",
        "        ],\n",
        "        \"data_sources\": [\n",
        "            {\"type\": \"azure_search\",\n",
        "             \"parameters\": {\n",
        "                 \"endpoint\": SEARCH_ENDPOINT,\n",
        "                 \"index_name\": SEARCH_INDEX_NAME,\n",
        "                 \"semantic_configuration\": SEMANTIC_CONFIGURATION,\n",
        "                 \"query_type\": \"semantic\",\n",
        "                 \"top_n_documents\": 20,\n",
        "                 \"authentication\": {\"type\": \"api_key\", \"key\": SEARCH_API_KEY}\n",
        "             }}\n",
        "        ],\n",
        "        \"temperature\": 0.7, \"max_tokens\": 800, \"top_p\": 0.95\n",
        "    }\n",
        "\n",
        "    try:\n",
        "        print(\"\\nSending request to Azure OpenAI...\")\n",
        "        response = requests.post(\n",
        "            f\"{AZURE_OPENAI_ENDPOINT}openai/deployments/{DEPLOYMENT_NAME}/chat/completions?api-version=2024-02-15-preview\",\n",
        "            headers=headers, json=payload\n",
        "        )\n",
        "        print(\"response.status_code: \", response.status_code)\n",
        "        if response.status_code != 200:\n",
        "            raise Exception(f\"Azure Search request failed with status code {response.status_code}\")\n",
        "\n",
        "        result = response.json()\n",
        "        raw_content = result['choices'][0]['message']['content'].strip()\n",
        "        print(f\"raw_content: {raw_content}\")\n",
        "        citations = result['choices'][0]['message'].get('context', {}).get('citations', [])\n",
        "\n",
        "        # Citations 내용 검사\n",
        "        if validate_citations(citations):\n",
        "            print(\"Valid citations found.\")\n",
        "            if \"The requested information is not available\" in raw_content or not raw_content:\n",
        "                print(\"Raw content is insufficient. Using citations for the response.\")\n",
        "                return summarize_with_gpt(citations, user_input, detected_language)\n",
        "            return summarize_with_gpt(citations, user_input, detected_language)\n",
        "        else:\n",
        "            print(\"No valid citations found. Triggering fallback...\")\n",
        "            return fallback_to_gpt(user_input, detected_language)\n",
        "\n",
        "    except Exception as e:\n",
        "        print(f\"Error encountered: {e}\")\n",
        "        return fallback_to_gpt(user_input, detected_language)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Note: {user_input} 을 받아서 {response}을 웹에서 보여주시면 됩니다! (2024.12.19)"
      ],
      "metadata": {
        "id": "_JZ1Zy2CqyWz"
      }
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.12.6"
    },
    "colab": {
      "provenance": []
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}